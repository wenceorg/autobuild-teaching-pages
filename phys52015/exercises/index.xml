<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Exercises on PHYS52015 – Introduction to HPC</title><link>https://teaching.wence.uk/phys52015/exercises/</link><description>Recent content in Exercises on PHYS52015 – Introduction to HPC</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://teaching.wence.uk/phys52015/exercises/index.xml" rel="self" type="application/rss+xml"/><item><title>Parallel Hello World</title><link>https://teaching.wence.uk/phys52015/exercises/hello/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/phys52015/exercises/hello/</guid><description>Hello, World! # As with every programming course, the first thing we will do is compile and run a &amp;ldquo;Hello world&amp;rdquo; program. Actually we&amp;rsquo;ll do three. The goal of this is to familiarise you with the module system on Hamilton, as well as how to compile code. So take a look at the quickstart guide if you haven&amp;rsquo;t already.
A serial version # Log in to Hamilton/COSMA load the relevant compiler modules</description></item><item><title>Vectorisation: loops with conditionals</title><link>https://teaching.wence.uk/phys52015/exercises/vectorisation-loop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/phys52015/exercises/vectorisation-loop/</guid><description>Vectorisation of a loop with conditionals # We&amp;rsquo;ll be running these exercises on Hamilton or COSMA, so remind yourself of how to log in and transfer code if you need to.
Some expensive calculations # In this exercise, we&amp;rsquo;re going to look at the ability of compilers to vectorise a loop in the presence of conditionals inside the loop body. The idea is to observe, and understand, what patterns permit (or do not permit) vectorisation.</description></item><item><title>Vectorisation: stencils</title><link>https://teaching.wence.uk/phys52015/exercises/vectorisation-stencil/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/phys52015/exercises/vectorisation-stencil/</guid><description>Vectorisation of a simple stencil # We&amp;rsquo;ll be running these exercises on Hamilton or COSMA, so remind yourself of how to log in and transfer code if you need to.
Blurring an image # One can blur or smooth the edges of an image by convolving the image with a normalised box kernel. Every output pixel \( g_{k, l} \) is created from the mean of the input image pixel \(f _{k, l}\) and its eight neighbours.</description></item><item><title>OpenMP: parallel loops</title><link>https://teaching.wence.uk/phys52015/exercises/openmp-loop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/phys52015/exercises/openmp-loop/</guid><description>Parallelisation of a simple loop # As usual, we&amp;rsquo;ll be running these exercises on Hamilton or COSMA, so remind yourself of how to log in and transfer code if you need to.
Obtaining the code # We&amp;rsquo;re going to use the same add_numbers code as we did in the previous vectorisation exercise. You should undo your edits from that exercise. If you can&amp;rsquo;t remember what you changed just download and unpack the code again.</description></item><item><title>OpenMP: stencils</title><link>https://teaching.wence.uk/phys52015/exercises/openmp-stencil/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/phys52015/exercises/openmp-stencil/</guid><description>Revisiting the stencil exercise # We&amp;rsquo;ll revisit the stencil computation that we used when looking at vectorisation. This time, we&amp;rsquo;re going to look at parallelisation with OpenMP.
Obtaining and compiling the code # If you already downloaded the code from the previous exercise you already have the code, otherwise get the tar archive and unpack it.
This time we&amp;rsquo;ll be working in the openmp subdirectory:
$ cd blur_image/openmp/ $ ls Makefile filters.</description></item><item><title>MPI: Calculating π</title><link>https://teaching.wence.uk/phys52015/exercises/mpi-pi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/phys52015/exercises/mpi-pi/</guid><description>Simple MPI parallelism # In this exercise we&amp;rsquo;re going to compute an approximation to the value of π using a simple Monte Carlo method. We do this by noticing that if we randomly throw darts at a square, the fraction of the time they will fall within the incircle approaches π.
Consider a square with side-length \(2r\) and an inscribed circle with radius \(r\).
Square with inscribed circle</description></item><item><title>MPI: halo exchanges</title><link>https://teaching.wence.uk/phys52015/exercises/mpi-stencil/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/phys52015/exercises/mpi-stencil/</guid><description>Data parallel stencil computations # In this exercise we&amp;rsquo;re going to explore an MPI-parallelisation of the image blurring exercise.
The natural thing to do here is to divide the work up between processes (much as we did for the OpenMP version).
Let&amp;rsquo;s have a look at what this would look like.
Decomposition of a 2D image into nine pieces
Remember that in MPI, each process has its own memory space.</description></item></channel></rss>
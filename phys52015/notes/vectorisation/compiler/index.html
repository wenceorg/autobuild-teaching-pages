<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Obtained vectorised code #  If we write code that we would like to be vectorised, we have multiple different options available to us on how to obtain it. We&rsquo;ll first list some approaches, briefly detail their strengths and weaknesses, and then go into more detail on the approach that we&rsquo;ll be using in this course.
First, some general advice. It is tempting to think of vectorisation as an optimisation that we can apply locally to our code."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Compiler autovectorisation"><meta property="og:description" content="Obtained vectorised code #  If we write code that we would like to be vectorised, we have multiple different options available to us on how to obtain it. We&rsquo;ll first list some approaches, briefly detail their strengths and weaknesses, and then go into more detail on the approach that we&rsquo;ll be using in this course.
First, some general advice. It is tempting to think of vectorisation as an optimisation that we can apply locally to our code."><meta property="og:type" content="article"><meta property="og:url" content="https://teaching.wence.uk/phys52015/notes/vectorisation/compiler/"><meta property="article:modified_time" content="2020-10-28T10:40:33+00:00"><title>Compiler autovectorisation | PHYS52015 – Introduction to HPC</title><link rel=manifest href=/phys52015/manifest.json><link rel=icon href=/phys52015/favicon.png type=image/x-icon><link rel=stylesheet href=/phys52015/book.min.bf7f3e732f1a68bc04f2ce50cc8c8a462404f04066d1e404f002f2914662d55d.css integrity="sha256-v38+cy8aaLwE8s5QzIyKRiQE8EBm0eQE8ALykUZi1V0="></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><div class=book-brand><img class=book-center src=/phys52015/logo.svg alt=Logo><h2><a href=/phys52015>PHYS52015 – Introduction to HPC</a></h2></div><ul><li><span>Administrivia</span><ul><li><a href=/phys52015/setup/hamilton-quickstart/>Hamilton access & quickstart</a></li><li><a href=/phys52015/setup/byod/>Local setup</a></li><li><a href=/phys52015/setup/configuration/>ssh configuration</a></li><li><a href=/phys52015/setup/unix/>Unix resources</a></li></ul></li><li><span>Exercises</span><ul><li><a href=/phys52015/exercises/hello/>Parallel Hello World</a></li><li><a href=/phys52015/exercises/vectorisation-loop/>Vectorisation: loops with conditionals</a></li><li><a href=/phys52015/exercises/vectorisation-stencil/>Vectorisation: stencils</a></li><li><a href=/phys52015/exercises/openmp-loop/>OpenMP: parallel loops</a></li><li><a href=/phys52015/exercises/openmp-stencil/>OpenMP: stencils & profiling</a></li><li><a href=/phys52015/exercises/mpi-pi/>MPI: Calculating π</a></li><li><a href=/phys52015/exercises/mpi-stencil/>MPI: halo exchanges</a></li></ul></li><li><span>Notes</span><ul><li><a href=/phys52015/notes/introduction/>Introduction and motivation</a></li><li><span>Theory & concepts</span><ul><li><a href=/phys52015/notes/theory/scaling-laws/>Parallel scaling laws</a></li><li><a href=/phys52015/notes/theory/hardware-parallelism/>Parallelism in hardware: an overview</a></li><li><a href=/phys52015/notes/theory/concepts/>Parallel patterns</a></li></ul></li><li><a href=/phys52015/notes/vectorisation/>Vectorisation</a><ul><li><a href=/phys52015/notes/vectorisation/compiler/ class=active>Compiler autovectorisation</a></li></ul></li><li><a href=/phys52015/notes/openmp/>OpenMP</a><ul><li><a href=/phys52015/notes/openmp/intro/>What is OpenMP?</a></li><li><a href=/phys52015/notes/openmp/loop-parallelism/>Loop parallelism</a></li><li><a href=/phys52015/notes/openmp/collectives/>Collectives</a></li><li><a href=/phys52015/notes/openmp/tasks/>Task parallelism</a></li></ul></li><li><a href=/phys52015/notes/mpi/>MPI</a><ul><li><a href=/phys52015/notes/mpi/mpi-ptp/>Point-to-point messaging</a></li><li><a href=/phys52015/notes/mpi/mpi-collectives/>Collectives</a></li><li><a href=/phys52015/notes/mpi/mpi-advanced/>Advanced topics</a></li></ul></li></ul></li><li><a href=/phys52015/coursework/>Coursework: parallel dense linear algebra</a><ul></ul></li><li><a href=/phys52015/resources/>Further resources</a></li><li><a href=/phys52015/acknowledgements/>Acknowledgements</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/phys52015/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Compiler autovectorisation</strong>
<label for=toc-control></label></div></header><article class=markdown><h1 id=obtained-vectorised-code>Obtained vectorised code
<a class=anchor href=#obtained-vectorised-code>#</a></h1><p>If we write code that we would like to be vectorised, we have multiple
different options available to us on how to obtain it. We&rsquo;ll first
list some approaches, briefly detail their strengths and weaknesses,
and then go into more detail on the approach that we&rsquo;ll be using in
this course.</p><p>First, some general advice. It is tempting to think of vectorisation
as an optimisation that we can apply locally to our code. In fact, we
should not think of it this way. Recalling <a href=https://teaching.wence.uk/phys52015/notes/theory/scaling-laws/#amdahl>Amdahl&rsquo;s Law</a>, if we only speed up a small part of our
code, we might not see a particular benefit. In addition,
vectorisation might necessitate some algorithmic restructuring and
data layout transformations. These are changes which have an effect on
the performance of the whole code.</p><p>As such, I advocate designing with vectorisation (and more generally
parallelism) in mind <em>from the start</em>. Keep this in mind when we&rsquo;re
looking at the examples of vectorisable loops in isolation.</p><h2 id=programming-approaches>Programming approaches
<a class=anchor href=#programming-approaches>#</a></h2><p>In order of increasing programmer control and complication, we have
broadly four options available to us to exploit vector hardware.</p><ol><li><p>Fully automatic via the compiler</p><p>Here we rely on automated analysis from the compiler to find
vectorisable parts of the code and apply the appropriate
transformation. This works well when there are simple loops.</p></li><li><p>Partially automatic: compiler + pragma-based source annotations</p><p>In this case, we still want the compiler to do the work, but we
will give it some hints by annotating our code with extra
information. Often this is needed because we have relatively simple
loops, but have a better idea than the compiler about whether
vectorisation is likely to be effective, or which loops should be
vectorised.</p></li><li><p>Explicit use of intrinsics</p><p>Here we use special variable types and replace normal code by calls
to functions that are turned into inline assembly. This is slightly
like writing &ldquo;semi-portable&rdquo; assembly. This is quite a complicated
approach, and makes your code far less readable.</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#75715e>/* Before */</span>
<span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>size_t</span> <span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>N</span><span style=color:#111>;</span> <span style=color:#111>i</span><span style=color:#f92672>++</span><span style=color:#111>)</span>
   <span style=color:#111>c</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>]</span> <span style=color:#f92672>=</span> <span style=color:#111>a</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>]</span> <span style=color:#f92672>+</span> <span style=color:#111>b</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>];</span>
<span style=color:#75715e>/* Vectorised with AVX2 intrinsics */</span>
<span style=color:#111>__m256d</span> <span style=color:#111>av</span><span style=color:#111>,</span> <span style=color:#111>bv</span><span style=color:#111>,</span> <span style=color:#111>cv</span><span style=color:#111>;</span>
<span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>size_t</span> <span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>N</span><span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span><span style=color:#111>)</span> <span style=color:#111>{</span>
    <span style=color:#111>av</span> <span style=color:#f92672>=</span> <span style=color:#111>_mm256_load_pd</span><span style=color:#111>(</span><span style=color:#111>a</span> <span style=color:#f92672>+</span> <span style=color:#111>i</span><span style=color:#111>);</span>
    <span style=color:#111>bv</span> <span style=color:#f92672>=</span> <span style=color:#111>_mm256_load_pd</span><span style=color:#111>(</span><span style=color:#111>b</span> <span style=color:#f92672>+</span> <span style=color:#111>i</span><span style=color:#111>);</span>
    <span style=color:#111>cv</span> <span style=color:#f92672>=</span> <span style=color:#111>_mm256_add_pd</span><span style=color:#111>(</span><span style=color:#111>av</span><span style=color:#111>,</span> <span style=color:#111>bv</span><span style=color:#111>);</span>
    <span style=color:#111>_mm256_store_pd</span><span style=color:#111>(</span><span style=color:#111>c</span> <span style=color:#f92672>+</span> <span style=color:#111>i</span><span style=color:#111>,</span> <span style=color:#111>cv</span><span style=color:#111>);</span>
<span style=color:#111>}</span>
</code></pre></div><blockquote class="book-hint info"><span>If you want to
know what these functions do, see the interactive <a href=https://software.intel.com/sites/landingpage/IntrinsicsGuide/>Intel intrinsics
guide</a></span></blockquote><p>This approach is not (immediately) portable to different vector
instruction sets (e.g. for AVX512 the load function is spelt
<code>_mm512_load_pd</code> rather than <code>_mm256_load_pd</code>). If going down this
route it&rsquo;s therefore best to wrap these things behind a library.
For C++, <a href=https://www.agner.org>Agner Fog</a> has a <a href=https://github.com/vectorclass/version2>nice
one</a>.</p></li><li><p>Explicitly writing assembly</p><p>This is similar to the previous case with intrinsics, but now we
don&rsquo;t rely on the compiler for control flow or register allocation
and have to do everything by hand.</p></li></ol><p>There is also a further class of methods that might rely on using
domain-specific languages or language extensions. We won&rsquo;t touch on
them here.</p><p>Given the complexity, and lack of portability, in the third and fourth
options. In this course we will only look at vectorisation available
via compiler optimisations, sometimes helped by pragma annotations.</p><h2 id=compiler-vectorisation-and-feedback>Compiler vectorisation and feedback
<a class=anchor href=#compiler-vectorisation-and-feedback>#</a></h2><p>The core idea in compiler (auto-)vectorisation is that the compiler
performs some analysis of your code, to determine whether or not
vectorisation (or in general any of the many optimisations it can
apply) is <em>possible</em>. Having determined that some strategy is
possible, the compiler then has to decide whether or not it is likely
to be profitable.</p><p>To do so, it has an (generally quite opaque) internal <em>cost model</em>.
That is, it has some model that attempts to predict how certain
optimisations will perform. For example, the cost model might say
&ldquo;switching from scalar code to 4-wide AVX vectors will provide a
factor of 3x speedup&rdquo;. In which case, probably vectorisation would
occur.</p><p>Unfortunately, the cost models are always incomplete, and often do not
choose wisely. In these situations we can help out by annotating our
source code.</p><p>To do so, we need to know what the compiler is deciding, and why. The
incantations necessary to open this dialogue with the compiler are
version-specific. I&rsquo;ll focus on the Intel compiler here, but also
provide some advice for GCC.</p><h3 id=optimisation-reports-for-intel>Optimisation reports for Intel
<a class=anchor href=#optimisation-reports-for-intel>#</a></h3><p>The Intel compiler will report information about the optimisation
decisions it made with the <code>-qopt-report</code> flag. We can control the
verbosity by saying <code>-qopt-report=n</code> for some <code>n=0..5</code>.</p><p>Let&rsquo;s look at how this works for a loop we hope is vectorisable</p><div class=book-include><div class=book-include-heading><tt>simple-vector.c</tt></div><div class=book-include-download><a href=https://teaching.wence.uk/phys52015/code/optimisation-snippets/simple-vector.c>Download</a></div><div class=book-include-content><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#00a8c8>void</span> <span style=color:#75af00>foo</span><span style=color:#111>(</span><span style=color:#00a8c8>double</span> <span style=color:#f92672>*</span><span style=color:#111>x</span><span style=color:#111>,</span> <span style=color:#00a8c8>int</span> <span style=color:#111>N</span><span style=color:#111>)</span>
<span style=color:#111>{</span>
  <span style=color:#00a8c8>int</span> <span style=color:#111>i</span><span style=color:#111>;</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>N</span><span style=color:#111>;</span> <span style=color:#111>i</span><span style=color:#f92672>++</span><span style=color:#111>)</span> <span style=color:#111>{</span>
    <span style=color:#111>x</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>]</span> <span style=color:#f92672>=</span> <span style=color:#111>x</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>]</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span><span style=color:#111>x</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>];</span>
  <span style=color:#111>}</span>
<span style=color:#111>}</span>
</code></pre></div></div></div><p>Running</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-sh data-lang=sh>$ icpc -qopt-report<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> -c -O3 -xCORE_AVX2 simple-vector.c
</code></pre></div><p>we get an optrpt file which we can inspect. You can also play along
with the <a href=https://gcc.godbolt.org>compiler explorer</a>, which is often
a more convenient way of doing things if you&rsquo;re just trying to check
vectorisation for a small amount of code. This example is prefilled
<a href=https://gcc.godbolt.org/z/WG9xxE>here</a>.</p><p>Looking at the optimisation report we see</p><pre><code>...
LOOP BEGIN at &lt;source&gt;(5,3)
   remark #15389: vectorization support: reference x[i] has unaligned access   [ &lt;source&gt;(6,5) ]
   remark #15389: vectorization support: reference x[i] has unaligned access   [ &lt;source&gt;(6,12) ]
   remark #15389: vectorization support: reference x[i] has unaligned access   [ &lt;source&gt;(6,21) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 1.429
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15450: unmasked unaligned unit stride loads: 1
   remark #15451: unmasked unaligned unit stride stores: 1
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 10
   remark #15477: vector cost: 1.750
   remark #15478: estimated potential speedup: 5.280
   remark #15488: --- end vector cost summary ---
LOOP END
</code></pre><p>So the loop was vectorised, and the cost model estimates a 5.2x
speedup.</p><p>Now let&rsquo;s look at example of <a href=https://teaching.wence.uk/phys52015/notes/vectorisation/#data-dep>flow dependence</a>.</p><div class=book-include><div class=book-include-heading><tt>flow-dep.c</tt></div><div class=book-include-download><a href=https://teaching.wence.uk/phys52015/code/optimisation-snippets/flow-dep.c>Download</a></div><div class=book-include-content><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#00a8c8>void</span> <span style=color:#75af00>foo</span><span style=color:#111>(</span><span style=color:#00a8c8>double</span> <span style=color:#f92672>*</span><span style=color:#111>x</span><span style=color:#111>,</span> <span style=color:#00a8c8>int</span> <span style=color:#111>N</span><span style=color:#111>)</span>
<span style=color:#111>{</span>
  <span style=color:#00a8c8>int</span> <span style=color:#111>i</span><span style=color:#111>;</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>N</span><span style=color:#111>;</span> <span style=color:#111>i</span><span style=color:#f92672>++</span><span style=color:#111>)</span> <span style=color:#111>{</span>
    <span style=color:#111>x</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>]</span> <span style=color:#f92672>=</span> <span style=color:#111>x</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>]</span> <span style=color:#f92672>+</span> <span style=color:#111>x</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>];</span>
  <span style=color:#111>}</span>
<span style=color:#111>}</span>
</code></pre></div></div></div><p>This time, we get a report of no vectorisation</p><pre><code>LOOP BEGIN at &lt;source&gt;(4,3)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between x[i] (5:5) and x[i-1] (5:5)
   remark #25439: unrolled with remainder by 2
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END
</code></pre><p>This says, on line 5, there is a read-after-write dependence between
the access to <code>x[i]</code> and <code>x[i-1]</code>.</p><p>These are relatively simple examples. Now let&rsquo;s look at one where the
compiler does the wrong thing.</p><div class=book-include><div class=book-include-heading><tt>gemm-microkernel.c</tt></div><div class=book-include-download><a href=https://teaching.wence.uk/phys52015/code/optimisation-snippets/gemm-microkernel.c>Download</a></div><div class=book-include-content><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#75715e>#define MR 4
</span><span style=color:#75715e>#define NR 8
</span><span style=color:#75715e></span>
<span style=color:#00a8c8>void</span> <span style=color:#75af00>micro_kernel</span><span style=color:#111>(</span><span style=color:#00a8c8>int</span> <span style=color:#111>kc</span><span style=color:#111>,</span>
                  <span style=color:#00a8c8>const</span> <span style=color:#00a8c8>double</span> <span style=color:#f92672>*</span> <span style=color:#00a8c8>restrict</span> <span style=color:#111>A</span><span style=color:#111>,</span>
                  <span style=color:#00a8c8>const</span> <span style=color:#00a8c8>double</span> <span style=color:#f92672>*</span> <span style=color:#00a8c8>restrict</span> <span style=color:#111>B</span><span style=color:#111>,</span>
                  <span style=color:#00a8c8>double</span> <span style=color:#f92672>*</span> <span style=color:#00a8c8>restrict</span> <span style=color:#111>AB</span><span style=color:#111>)</span>
<span style=color:#111>{</span>
  <span style=color:#00a8c8>int</span> <span style=color:#111>i</span><span style=color:#111>,</span> <span style=color:#111>j</span><span style=color:#111>,</span> <span style=color:#111>l</span><span style=color:#111>;</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>l</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>l</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>kc</span><span style=color:#111>;</span> <span style=color:#f92672>++</span><span style=color:#111>l</span><span style=color:#111>)</span> <span style=color:#111>{</span>
    <span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>j</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>j</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>NR</span><span style=color:#111>;</span> <span style=color:#f92672>++</span><span style=color:#111>j</span><span style=color:#111>)</span>
      <span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>MR</span><span style=color:#111>;</span> <span style=color:#f92672>++</span><span style=color:#111>i</span><span style=color:#111>)</span>
        <span style=color:#111>AB</span><span style=color:#111>[</span><span style=color:#111>i</span> <span style=color:#f92672>+</span> <span style=color:#111>j</span><span style=color:#f92672>*</span><span style=color:#111>MR</span><span style=color:#111>]</span> <span style=color:#f92672>+=</span> <span style=color:#111>A</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>]</span> <span style=color:#f92672>*</span> <span style=color:#111>B</span><span style=color:#111>[</span><span style=color:#111>j</span><span style=color:#111>];</span>
    <span style=color:#111>A</span> <span style=color:#f92672>+=</span> <span style=color:#111>MR</span><span style=color:#111>;</span>
    <span style=color:#111>B</span> <span style=color:#f92672>+=</span> <span style=color:#111>NR</span><span style=color:#111>;</span>
  <span style=color:#111>}</span>
<span style=color:#111>}</span>
</code></pre></div></div></div><p>Again, play along <a href=https://gcc.godbolt.org/z/7Pf9fK>on the compiler
explorer</a>.</p><p>At first glance, everything looks fine. The compiler reports
vectorisation occurred, with a modest estimated speedup.</p><pre><code>...
         remark #15301: PERMUTED LOOP WAS VECTORIZED
         remark #15452: unmasked strided loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 8 
         remark #15477: vector cost: 5.250 
         remark #15478: estimated potential speedup: 1.470 
         remark #15488: --- end vector cost summary ---
</code></pre><p>However, this is a case where I, as the programmer, expect larger
gains. And the &ldquo;permuted&rdquo; part gives me cause for concern<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>Reading the rest of the report, I see</p><pre><code>   remark #25444: Loopnest Interchanged: ( 1 2 3 ) --&gt; ( 2 3 1 )
</code></pre><p>So the compiler obviously decided to reorder the loops and then
vectorised the (originally outermost) now innermost loop. It&rsquo;s cost
model is wrong!</p><p>What can we do to fix this?</p><h3 id=controlling-what-the-compiler-does>Controlling what the compiler does
<a class=anchor href=#controlling-what-the-compiler-does>#</a></h3><p>In this instance, we know better than the compiler, and we want it to
vectorise the original innermost loop. To do so, we can use
<a href=https://en.wikipedia.org/wiki/Directive_%28programming%29><code>#pragma</code></a>
annotation to give the compiler some extra information that will help
guide its cost model (or just tell it what to do).</p><p>These pragmas are generally compiler-specific. Although for
vectorisation purposes a number are being standardised through
<a href=https://www.openmp.org>OpenMP</a>.</p><p>Since pragmas are compiler-specific, the canonical place to look for
information is always the compiler manual, which details supported
language extensions. Intel has <a href=https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/pragmas/intel-specific-pragma-reference.html#intel-specific-pragma-reference>extensive
documentation</a>,
<a href=https://gcc.gnu.org/onlinedocs/gcc/Pragmas.html>GCC</a> and
<a href=https://clang.llvm.org/docs/LanguageExtensions.html#extensions-for-selectively-disabling-optimization>Clang</a>
somewhat less.</p><p>A few relevant ones are</p><ol><li><p>Loop unrolling<div class=book-tabs><input type=radio class=toggle name=tabs-unroll id=tabs-unroll-0 checked>
<label for=tabs-unroll-0>Intel</label><div class="book-tabs-content markdown-inner"><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#75715e>/* Unroll, but use heuristics */</span>
<span style=color:#75715e>#pragma unroll
</span><span style=color:#75715e></span><span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>N</span><span style=color:#111>;</span> <span style=color:#111>i</span><span style=color:#f92672>++</span><span style=color:#111>)</span>
  <span style=color:#111>...</span>
  
<span style=color:#75715e>/* Unroll specified number of times. n must be a literal number */</span>
<span style=color:#75715e>#pragma unroll(n)
</span><span style=color:#75715e></span><span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>N</span><span style=color:#111>;</span> <span style=color:#111>i</span><span style=color:#f92672>++</span><span style=color:#111>)</span>
  <span style=color:#111>...</span>
  

<span style=color:#75715e>/* Don&#39;t unroll */</span>
<span style=color:#75715e>#pragma nounroll
</span><span style=color:#75715e></span><span style=color:#00a8c8>for</span> <span style=color:#111>...</span>
</code></pre></div><p>See <a href=https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/pragmas/intel-specific-pragma-reference/unroll-nounroll.html#unroll-nounroll>the
documentation</a>
for details.</p></div><input type=radio class=toggle name=tabs-unroll id=tabs-unroll-1>
<label for=tabs-unroll-1>GCC</label><div class="book-tabs-content markdown-inner"><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#75715e>/* Unroll specified number of times. n must be a literal number */</span>
<span style=color:#75715e>#pragma GCC unroll n
</span><span style=color:#75715e></span><span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>N</span><span style=color:#111>;</span> <span style=color:#111>i</span><span style=color:#f92672>++</span><span style=color:#111>)</span>
  <span style=color:#111>...</span>

<span style=color:#75715e>/* Use n=0,1 for no unrolling */</span>
</code></pre></div><p>See their
<a href=https://gcc.gnu.org/onlinedocs/gcc/Loop-Specific-Pragmas.html#Loop-Specific-Pragmas>docs</a>.</p></div><input type=radio class=toggle name=tabs-unroll id=tabs-unroll-2>
<label for=tabs-unroll-2>clang</label><div class="book-tabs-content markdown-inner"><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#75715e>/* Unroll specified number of times. n must be a literal number */</span>
<span style=color:#75715e>#pragma clang loop unroll_count(n)
</span><span style=color:#75715e></span><span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>N</span><span style=color:#111>;</span> <span style=color:#111>i</span><span style=color:#f92672>++</span><span style=color:#111>)</span>
  <span style=color:#111>...</span>

<span style=color:#75715e>/* Disable unrolling */</span>
<span style=color:#75715e>#pragma clang loop unroll(disable)
</span></code></pre></div><p>See their <a href=https://clang.llvm.org/docs/LanguageExtensions.html#loop-unrolling>docs</a>.</p></div></div></p></li><li><p>Disregarding data dependencies<div class=book-tabs><input type=radio class=toggle name=tabs-data-dep id=tabs-data-dep-0 checked>
<label for=tabs-data-dep-0>Intel</label><div class="book-tabs-content markdown-inner"><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#75715e>/* Ignore assumed flow-dependence */</span>
<span style=color:#75715e>#pragma ivdep
</span><span style=color:#75715e></span><span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#111>k</span><span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>N</span><span style=color:#111>;</span> <span style=color:#111>i</span><span style=color:#f92672>++</span><span style=color:#111>)</span>
  <span style=color:#111>a</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>]</span> <span style=color:#f92672>=</span> <span style=color:#111>a</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#f92672>-</span><span style=color:#111>k</span><span style=color:#111>]</span> <span style=color:#f92672>+</span> <span style=color:#111>a</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>];</span>
</code></pre></div><p>In this case, if <code>k</code> is a runtime value, the compiler must assume that
there is a dependency (and will not vectorise). Using <code>#pragma ivdep</code>
we promise &ldquo;no no, it&rsquo;s all fine!&rdquo;. See <a href=https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/pragmas/intel-specific-pragma-reference/ivdep.html#ivdep>Intel&rsquo;s
documentation</a>
for details.</p><blockquote class="book-hint warning"><span>You need to make sure that it actually is all fine! If <code>k = 1</code> then we
would get bad code with <code>ivdep</code>.</span></blockquote></div><input type=radio class=toggle name=tabs-data-dep id=tabs-data-dep-1>
<label for=tabs-data-dep-1>GCC</label><div class="book-tabs-content markdown-inner"><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#75715e>#pragma GCC ivdep
</span><span style=color:#75715e></span><span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#111>k</span><span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>N</span><span style=color:#111>;</span> <span style=color:#111>i</span><span style=color:#f92672>++</span><span style=color:#111>)</span>
  <span style=color:#111>a</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>]</span> <span style=color:#f92672>=</span> <span style=color:#111>a</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#f92672>-</span><span style=color:#111>k</span><span style=color:#111>]</span> <span style=color:#f92672>+</span> <span style=color:#111>a</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>];</span>
</code></pre></div><p>See their
<a href=https://gcc.gnu.org/onlinedocs/gcc/Loop-Specific-Pragmas.html#Loop-Specific-Pragmas>docs</a>.</p></div><input type=radio class=toggle name=tabs-data-dep id=tabs-data-dep-2>
<label for=tabs-data-dep-2>clang</label><div class="book-tabs-content markdown-inner">It does not appear to be possible to specify pragmas for clang right now.</div></div></p></li><li><p>Force SIMD vectorisation of loops.</p><p>This is enabled in a cross-compiler manner using the OpenMP
<a href=https://www.openmp.org/spec-html/5.0/openmpsu42.html><code>#pragma omp simd</code></a>
construct. You will need to enable recognition of these pragmas
by adding <code>-qomp-simd</code> (Intel) or <code>-fopenmp-simd</code> (GCC/Clang).</p></li></ol><p>Having done this, we can now go back and try annotating the code that
was treated &ldquo;badly&rdquo; by the compiler.</p><div class=book-include><div class=book-include-heading><tt>gemm-microkernel-annotated.c</tt></div><div class=book-include-download><a href=https://teaching.wence.uk/phys52015/code/optimisation-snippets/gemm-microkernel-annotated.c>Download</a></div><div class=book-include-content><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#75715e>#define MR 4
</span><span style=color:#75715e>#define NR 8
</span><span style=color:#75715e></span>
<span style=color:#00a8c8>void</span> <span style=color:#75af00>micro_kernel</span><span style=color:#111>(</span><span style=color:#00a8c8>int</span> <span style=color:#111>kc</span><span style=color:#111>,</span>
                  <span style=color:#00a8c8>const</span> <span style=color:#00a8c8>double</span> <span style=color:#f92672>*</span> <span style=color:#00a8c8>restrict</span> <span style=color:#111>A</span><span style=color:#111>,</span>
                  <span style=color:#00a8c8>const</span> <span style=color:#00a8c8>double</span> <span style=color:#f92672>*</span> <span style=color:#00a8c8>restrict</span> <span style=color:#111>B</span><span style=color:#111>,</span>
                  <span style=color:#00a8c8>double</span> <span style=color:#f92672>*</span> <span style=color:#00a8c8>restrict</span> <span style=color:#111>AB</span><span style=color:#111>)</span>
<span style=color:#111>{</span>
  <span style=color:#00a8c8>int</span> <span style=color:#111>i</span><span style=color:#111>,</span> <span style=color:#111>j</span><span style=color:#111>,</span> <span style=color:#111>l</span><span style=color:#111>;</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>l</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>l</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>kc</span><span style=color:#111>;</span> <span style=color:#f92672>++</span><span style=color:#111>l</span><span style=color:#111>)</span> <span style=color:#111>{</span>
<span style=color:#75715e>#pragma unroll(8)
</span><span style=color:#75715e></span>    <span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>j</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>j</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>NR</span><span style=color:#111>;</span> <span style=color:#f92672>++</span><span style=color:#111>j</span><span style=color:#111>)</span>
<span style=color:#75715e>#pragma omp simd
</span><span style=color:#75715e></span>      <span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>MR</span><span style=color:#111>;</span> <span style=color:#f92672>++</span><span style=color:#111>i</span><span style=color:#111>)</span>
        <span style=color:#111>AB</span><span style=color:#111>[</span><span style=color:#111>i</span> <span style=color:#f92672>+</span> <span style=color:#111>j</span><span style=color:#f92672>*</span><span style=color:#111>MR</span><span style=color:#111>]</span> <span style=color:#f92672>+=</span> <span style=color:#111>A</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>]</span> <span style=color:#f92672>*</span> <span style=color:#111>B</span><span style=color:#111>[</span><span style=color:#111>j</span><span style=color:#111>];</span>
    <span style=color:#111>A</span> <span style=color:#f92672>+=</span> <span style=color:#111>MR</span><span style=color:#111>;</span>
    <span style=color:#111>B</span> <span style=color:#f92672>+=</span> <span style=color:#111>NR</span><span style=color:#111>;</span>
  <span style=color:#111>}</span>
<span style=color:#111>}</span>
</code></pre></div></div></div><p><a href=https://gcc.godbolt.org/z/91qc1j>This time</a>, we see a better result.</p><pre><code>LOOP BEGIN at &lt;source&gt;(10,3)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at &lt;source&gt;(12,5)
      remark #15542: loop was not vectorized: inner loop was already vectorized
      remark #25436: completely unrolled by 8  

      LOOP BEGIN at &lt;source&gt;(14,12)
         ...
         remark #15427: loop was completely unrolled
         remark #15309: vectorization support: normalized vectorization overhead 0.909
         remark #15301: OpenMP SIMD LOOP WAS VECTORIZED
</code></pre><h3 id=was-it-worth-it>Was it worth it?
<a class=anchor href=#was-it-worth-it>#</a></h3><p>This micro-kernel is at the core of fast dense matrix-matrix
multiplication, and it (or assembly that is similar) is used in the
fast <a href=https://github.com/flame/blis/>BLIS</a> library.</p><p>With GCC-10, rather than Intel, if I don&rsquo;t annotate the microkernel, I
get throughput on \(4096 \times 4096 \) matrices of around
3.5GFlops/s on my laptop (38 seconds per multiplication). After
appropriate annotations, I get around 38GFlops/s for the same problem
(3.6 seconds per multiplication). A speedup of more than 11.#</p><p>In comparison, the highly-optimised
<a href=https://www.openblas.net>openblas</a> library achieves 51GFlops/s (2.7
seconds per multiplication).</p><h3 id=flags-for-gcc-and-clang>Flags for GCC and Clang
<a class=anchor href=#flags-for-gcc-and-clang>#</a></h3><p>GCC and Clang also have ways of requesting information on what the
optimiser is doing. For GCC, use
<a href=https://gcc.gnu.org/onlinedocs/gcc/Developer-Options.html><code>-fopt-info</code></a>.
For Clang, use
<a href=https://clang.llvm.org/docs/UsersManual.html#rpass><code>-Rpass=vec</code></a>.
See also the <a href=https://llvm.org/docs/Vectorizers.html>LLVM vectoriser</a> docs.</p><h2 id=summary>Summary
<a class=anchor href=#summary>#</a></h2><p>Vectorisation is necessary for peak performance on modern hardware.
Generally, unless your job is developing high-performance numerical
libraries, it is best to leave the details to the compiler.</p><p>That said, we sometimes have to help the compiler&rsquo;s cost model along
with judicious use of pragma annotations. We saw some examples.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>To understand why, take
<a href=https://teaching.wence.uk/comp52315/>COMP52315</a> next term! <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/wenceorg/phys52015/commit/7582099b894ebe59936de6cd4d1e0feb7dea0c4a title="Last modified by Lawrence Mitchell | October 28, 2020" target=_blank rel=noopener><img src=/phys52015/svg/calendar.svg class=book-icon alt=Calendar>
<span>October 28, 2020</span></a></div><div><a class="flex align-center" href=https://github.com/wenceorg/phys52015/edit/main/site/content/notes/vectorisation/compiler.md target=_blank rel=noopener><img src=/phys52015/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div class="flex flex-wrap align-right"><p>© 2020&ndash; <a href=mailto:lawrence@wence.uk>Lawrence Mitchell</a>, <a href="https://www.dur.ac.uk/physics/staff/profiles/?mode=staff&id=16712">Christian Arnold</a> & <a href=https://www.dur.ac.uk/>Durham University</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/><img alt="Creative Commons License" style=border-width:0 src=/phys52015/cc-by-sa.svg></a>
This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/>Creative
Commons Attribution-ShareAlike 4.0 International License</a>.</p></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div></main></body></html>
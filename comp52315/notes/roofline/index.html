<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Models of performance #  If our goal is to improve the performance of some code we should take a scientific approach. We must first define what we mean by performance. So far, we&rsquo;ve talked about floating point throughput (GFlops/s) or memory bandwidth (GBytes/s). However, these are really secondary characteristics to the primary metric of performance of a code:
How long do I have to wait until I get the answer?"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Performance models: roofline"><meta property="og:description" content="Models of performance #  If our goal is to improve the performance of some code we should take a scientific approach. We must first define what we mean by performance. So far, we&rsquo;ve talked about floating point throughput (GFlops/s) or memory bandwidth (GBytes/s). However, these are really secondary characteristics to the primary metric of performance of a code:
How long do I have to wait until I get the answer?"><meta property="og:type" content="article"><meta property="og:url" content="https://teaching.wence.uk/comp52315/notes/roofline/"><meta property="article:modified_time" content="2020-12-10T19:02:37+00:00"><title>Performance models: roofline | COMP52315 – Performance Engineering</title><link rel=manifest href=/comp52315/manifest.json><link rel=icon href=/comp52315/favicon.png type=image/x-icon><link rel=stylesheet href=/comp52315/book.min.0cb0b7d6a1ed5d0e95321cc15edca4d6e9cc406149d1f4a3f25fd532f6a3bb38.css integrity="sha256-DLC31qHtXQ6VMhzBXtyk1unMQGFJ0fSj8l/VMvajuzg="></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><div class=book-brand><img class=book-center src=/comp52315/logo.svg alt=Logo><h2><a href=/comp52315>COMP52315 – Performance Engineering</a></h2></div><ul><li><span>Administrivia</span><ul><li><a href=/comp52315/setup/contact/>Contact details</a></li><li><a href=/comp52315/setup/hamilton/>Hamilton accounts</a></li><li><a href=/comp52315/setup/configuration/>ssh configuration</a></li><li><a href=/comp52315/setup/unix/>Unix resources</a></li></ul></li><li><span>Exercises</span><ul><li><a href=/comp52315/exercises/exercise01/>Exercise 1: sum reductions</a></li><li><a href=/comp52315/exercises/exercise02/>Exercise 2: caches</a></li><li><a href=/comp52315/exercises/exercise03/>Exercise 3: memory bandwidth</a></li><li><a href=/comp52315/exercises/exercise04/>Exercise 4: roofline analysis</a></li><li><a href=/comp52315/exercises/exercise05/>Exercise 5: models and measurements</a></li><li><a href=/comp52315/exercises/exercise06/>Exercise 6: profiling</a></li><li><a href=/comp52315/exercises/exercise07/>Exercise 7: loop tiling matrix transpose</a></li><li><a href=/comp52315/exercises/exercise08/>Exercise 8: loop tiling matrix-matrix multiplication</a></li><li><a href=/comp52315/exercises/exercise09/>Exercise 9: compiler feedback</a></li><li><a href=/comp52315/exercises/exercise10/>Exercise 10: stencil layer conditions</a></li></ul></li><li><span>Notes</span><ul><li><a href=/comp52315/notes/introduction/>Introduction</a></li><li><a href=/comp52315/notes/memory/>The memory hierarchy</a></li><li><a href=/comp52315/notes/roofline/ class=active>Performance models: roofline</a></li></ul></li><li><a href=/comp52315/coursework/>Coursework: fast finite elements</a><ul></ul></li><li><a href=/comp52315/acknowledgements/>Acknowledgements & further reading</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/comp52315/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Performance models: roofline</strong>
<label for=toc-control></label></div></header><article class=markdown><h1 id=models-of-performance>Models of performance
<a class=anchor href=#models-of-performance>#</a></h1><p>If our goal is to improve the performance of some code we should take
a scientific approach. We must first define what we mean by
<em>performance</em>. So far, we&rsquo;ve talked about floating point throughput
(GFlops/s) or memory bandwidth (GBytes/s). However, these are really
secondary characteristics to the primary metric of performance of a
code:</p><p><strong>How long do I have to wait until I get the answer?</strong></p><p>Therefore, we should not lose sight of the overall target of any
performance optimisation study, which is to <em>minimise the time to
solution</em> for a given code.</p><p>Our goal is then to come up with a hypothesis-driven optimisation
cycle. A simple flow diagram is shown below</p><figure><img src=https://teaching.wence.uk/comp52315/images/manual/optimisationworkflow.png alt="Simplified flow diagram for deciding on next steps when optimising code" width=30%><figcaption><p>Simplified flow diagram for deciding on next steps when optimising code</p></figcaption></figure><p>The idea is that we decide that the time to solution is too long, and
must therefore optimise the code. We <em>profile</em> the code to determine
where it spends all (or most) of its time, and then construct a model
that explains that time. With a model in hand, we can make a
prediction about the best optimisation to apply.</p><p>This allows us to focus our optimisation efforts where they will be
most effective.</p><p>To do this, we need to construct some models, we&rsquo;ll see a number of
approaches in this course, the first one we&rsquo;ll consider is the
<a href=https://doi.org/10.1145/1498765.1498785><em>roofline model</em></a>. This is a
simple model for loopy heavy code.</p><h2 id=roofline-model>Roofline model
<a class=anchor href=#roofline-model>#</a></h2><p>The roofline model has a simple view of both hardware and software</p><div class="book-columns flex flex-wrap"><div class="flex-even markdown-inner"><h3 id=simple-view-of-hardware>Simple view of hardware</h3><figure><img src=https://teaching.wence.uk/comp52315/images/manual/rooflinecpumodel.png width=100%></figure></div><div class="flex-even markdown-inner"><h3 id=simple-view-of-software>Simple view of software</h3><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#75715e>/* Possibly nested loops */</span>
<span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>...;</span> <span style=color:#111>i</span><span style=color:#f92672>++</span><span style=color:#111>)</span>
 <span style=color:#75715e>/* Complicated code doing */</span>
 <span style=color:#75715e>/* N FLOPs causing
</span><span style=color:#75715e> /* B bytes of data transfer */</span>
</code></pre></div><p>This allows us to characterise the code using a single number, its
<em>operational intensity</em>, measured in FLOPs/byte</p><p>$$
I_c = \frac{N}{B}
$$</p></div></div><p>To this characterisation of the software, we add two numbers that
characterise the hardware</p><ol><li>The <em>peak floating point performance</em> \(P_\text{peak}\) measured
in FLOPs/s</li><li>The <em>peak streaming memory bandwidth</em> \(B_\text{peak}\) measured
in bytes/s</li></ol><p>Our challenge is then to ask what the limit on the performance of a
piece of code is. We characterise performance by how fast work can be
done, measured in FLOPs/s. The roofline model says that the bottleneck
is either due to</p><ol><li>execution of work, limited by \(P_\text{peak}\),</li><li>or the data path \(I_c B_\text{peak}\).</li></ol><p>We therefore arrive at a bound on performance</p><p>$$
P_\text{max} = \text{min}(P_\text{peak}, I_c B_\text{peak})
$$</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/wenceorg/comp52315/commit/45a311d187cd787cc59e0e7754014a8576c9a9eb title="Last modified by Lawrence Mitchell | December 10, 2020" target=_blank rel=noopener><img src=/comp52315/svg/calendar.svg class=book-icon alt=Calendar>
<span>December 10, 2020</span></a></div><div><a class="flex align-center" href=https://github.com/wenceorg/comp52315/edit/main/site/content//notes/roofline.md target=_blank rel=noopener><img src=/comp52315/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div class="flex flex-wrap align-right"><p>© 2020&ndash; <a href=mailto:lawrence@wence.uk>Lawrence Mitchell</a> and <a href=https://www.dur.ac.uk/>Durham University</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/><img alt="Creative Commons License" style=border-width:0 src=/comp52315/cc-by-sa.svg></a>
This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/>Creative
Commons Attribution-ShareAlike 4.0 International License</a>.</p></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div></main></body></html>
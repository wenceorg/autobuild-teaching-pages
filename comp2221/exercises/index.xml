<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Exercises on COMP2221 – Functional Programming</title><link>https://teaching.wence.uk/comp2221/exercises/</link><description>Recent content in Exercises on COMP2221 – Functional Programming</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://teaching.wence.uk/comp2221/exercises/index.xml" rel="self" type="application/rss+xml"/><item><title>Hello, World!</title><link>https://teaching.wence.uk/comp2221/exercises/exercise1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp2221/exercises/exercise1/</guid><description>Beginnings # GHC provides either a compiler, with which we can compile a Haskell program into an executable, and an interpreter with a read-eval-print-loop. Initially, we&amp;rsquo;ll start off using the interpreter. It can be invoked with ghci, so at a terminal prompt run
$ ghci When I show commands in the terminal, I will use a $ to indicate the prompt (which you should not type), followed by the command to type.</description></item><item><title>Types and lists</title><link>https://teaching.wence.uk/comp2221/exercises/exercise2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp2221/exercises/exercise2/</guid><description>Thinking about types # You&amp;rsquo;ve probably noticed by now that GHC will complain if you write some code where the types don&amp;rsquo;t match. To do this, it uses type inference to determine the valid types of any functions you write, and checks that everything works. For example, suppose I have a function
allTrue :: [Bool] -&amp;gt; Bool allTrue [] = True allTrue (x:xs) = x &amp;amp;&amp;amp; allTrue xs which checks if every entry of a list of Bools is True.</description></item><item><title>List manipulation and sorting</title><link>https://teaching.wence.uk/comp2221/exercises/exercise3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp2221/exercises/exercise3/</guid><description>More list manipulation # We&amp;rsquo;ll start off doing a bit more list manipulation, looking at some list comprehensions and pattern matching. Then we&amp;rsquo;ll implement merge sort.
List comprehensions &amp;amp; pattern matching # For this section, the template code is code/lists-exercise3.hs.
Let&amp;rsquo;s first look at some pattern matching, and combination with guard expressions.
Exercise Write a function compress :: Eq a =&amp;gt; [a] -&amp;gt; [a] that eliminates consecutive duplicate elements of a list, but otherwise leaves the order unchanged.</description></item></channel></rss>
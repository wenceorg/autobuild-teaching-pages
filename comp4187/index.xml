<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on COMP4187 – Parallel Scientific Computing II</title><link>https://teaching.wence.uk/comp4187/</link><description>Recent content in Introduction on COMP4187 – Parallel Scientific Computing II</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://teaching.wence.uk/comp4187/index.xml" rel="self" type="application/rss+xml"/><item><title>Jupyter</title><link>https://teaching.wence.uk/comp4187/setup/jupyter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/setup/jupyter/</guid><description>Running the notebooks # To install the necessary software, I recommend doing so in a Python virtual environment. We need Python3. Doing something like:
$ python3 -m venv sci-comp $ . sci-comp/bin/activate # Or other script if you use a different shell $ pip install numpy scipy pandas ipython jupyter $ cd path/to/repo/material $ jupyter notebook Will pop up a browser window.
If this results in an AssertionError (see https://github.</description></item><item><title>Lecture 1: FD</title><link>https://teaching.wence.uk/comp4187/lectures/numerics/lecture1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/numerics/lecture1/</guid><description>The lecture will take place over zoom. A calender invite is available on duo. The zoom invite can also be found at info).
Before the lecture it would be good if you can download the ipython notebook and run it. You can see jupyter for instructions on how to run the notebook.
Alternatively, you can run the notebook online without installing python.
finite-differences After the lecture a video recording has been placed on duo.</description></item><item><title>Parallel Hello World</title><link>https://teaching.wence.uk/comp4187/exercises/parallel/hello/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/exercises/parallel/hello/</guid><description>Hello, World! # Every programming course has to start with &amp;ldquo;hello world&amp;rdquo;, this is no exception. The goal of this is to familiarise you with compiling and running code using MPI, the parallel library we&amp;rsquo;ll be using, either on Hamilton, or your own machine. So take a look at the setup guide if you haven&amp;rsquo;t already.
A Python version # MPI is a specification for a library-based programming model.</description></item><item><title>Point-to-point messaging in MPI</title><link>https://teaching.wence.uk/comp4187/lectures/mpi/point-to-point/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/mpi/point-to-point/</guid><description>Pairwise message exchange # The simplest form of communication in MPI is a pairwise exchange of a message between two processes.
In MPI, communication via messages is two-sided1. That is, for every message one process sends, there must be a matching receive call by another process.
Cartoon of sending a message between two processes
We need to fill in some details
How will we describe &amp;ldquo;data&amp;rdquo; How will we identify processes How will the receiver know which message to put where?</description></item><item><title>Coarse Grid Operator</title><link>https://teaching.wence.uk/comp4187/exercises/coarse-grid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/exercises/coarse-grid/</guid><description>Constructing a coarse grid operator # We consider the discrete Poisson system with Dirichlet boundary conditions and 7 grid points, $$\frac{-u_{i-1} + 2 u_i - u_{i+1}}{h^2} = f_i, i=1\dots 5$$ $$u_0 = u_6 = 1, \text{(inhomogeneous)}$$ where the mesh size is $h:=\frac{1}{6}$.
Formulate the system of equations in matrix form, i.e. $A_h u = b_h$. Take care with the boundary conditions. Define a linear mapping $R: \mathbb{R}^5 \rightarrow \mathbb{R}^2$ according to the full weighting scheme.</description></item><item><title>Finite Differences</title><link>https://teaching.wence.uk/comp4187/exercises/finite-differences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/exercises/finite-differences/</guid><description>Finite Differences # Consider the one-dimensional Poisson equation with homogeneous Dirichlet conditions $$-\frac{d^2 u}{d x^2}=f(x),~~~x\in(0,1)$$ with Dirichlet boundary conditions $$u(0)=u(1) = 0.$$
Discretise the Poisson equation by finite differences using an equidistant mesh size $h=1/N$ and $N+1$ grid points. Write the finite difference approximation from 1. in matrix-vector form $Au=b$. Therefore, define the entries of the matrix $A\in\mathbb{R}^{N+1\times N+1}$. Write the finite difference approximation as $Au=b$, where $A\in\mathbb{R}^{N-1\times N-1}$ and $b\in\mathbb{R}^{N-1}$, by substituting the values for $u(0)$ and $u(1)$.</description></item><item><title>Lecture 2: FD</title><link>https://teaching.wence.uk/comp4187/lectures/numerics/lecture2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/numerics/lecture2/</guid><description>For this lecture we continued with ipython notebook.
The notebook is also available online without installing python.
finite-differences After the lecture a video recording has been placed on duo. The video is now available at: video</description></item><item><title>MPI</title><link>https://teaching.wence.uk/comp4187/setup/mpi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/setup/mpi/</guid><description>Options for running MPI programs # For the larger parallel runs in the course, and benchmarking, we will use the Hamilton cluster. You may wish to do development on your own machine. I provide some brief guidance on what you need in terms of appropriate compilers and MPI implementations.
Hamilton access and quickstart # If you don&amp;rsquo;t already have an account on Hamilton, please register for one by following their instructions.</description></item><item><title>Non-blocking point-to-point messaging</title><link>https://teaching.wence.uk/comp4187/lectures/mpi/point-to-point-nb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/mpi/point-to-point-nb/</guid><description>Non-blocking messages # As well as the blocking point to point messaging we saw last time, MPI also offers non-blocking versions.
These functions all return immediately, and provide a &amp;ldquo;request&amp;rdquo; object that we can then either wait for completion with or inspect to check if the message has been sent/received.
The function signatures for MPI_Isend and MPI_Irecv are:
int MPI_Isend(const void *buffer, int count, MPI_Datatype dtype, int dest, int tag, MPI_Comm comm, MPI_Request *request); int MPI_Irecv(void *buffer, int count, MPI_Datatype dtype, int dest, int tag, MPI_Comm comm, MPI_Request *request); The mpi4py versions are:</description></item><item><title>Two-Grid Iteration</title><link>https://teaching.wence.uk/comp4187/exercises/two-grid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/exercises/two-grid/</guid><description>Fourier Analysis for Two-Grid Iteration # You can find the exercise in the following ipython notebook: ipython notebook</description></item><item><title>Collectives</title><link>https://teaching.wence.uk/comp4187/lectures/mpi/collectives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/mpi/collectives/</guid><description>Collective communication # Point-to-point messages are sufficient to write all the parallel algorithms we might want. However, they might not necessarily be the most efficient.
As motivation, let&amp;rsquo;s think about the time we would expect the [ring reduction]({{ ref &amp;ldquo;mpi-ring.md&amp;rdquo; }}) you implemented to take as a function of the number of processes.
Recall from the [ping-pong exercise]({{ ref &amp;ldquo;mpi-ping-pong.md&amp;rdquo; }}) that our model for the length of time it takes to send a message with $B$ bytes is</description></item><item><title>Lecture 3: FD</title><link>https://teaching.wence.uk/comp4187/lectures/numerics/lecture3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/numerics/lecture3/</guid><description>We will be moving on to the next notebook during the next lecture. Before the lecture it would be good if you can download the next ipython notebook and run it. You can see jupyter for instructions on how to run the notebook.
Alternatively, you can run the notebook online without installing python.
finite-differences The video is now available at: video
The content of the whiteboard can be found below.</description></item><item><title>Advanced topics</title><link>https://teaching.wence.uk/comp4187/lectures/mpi/advanced/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/mpi/advanced/</guid><description>Some pointers to more advanced features of MPI # Communicator manipulation # We saw that we can distinguish point-to-point messages by providing different tags, but that there was no such facility for collective operations. Moreover, a collective operation (by definition) involves all the processes in a communicator.
This raises two questions:
How can we have multiple collective operations without them interfering with each other; What if we want a collective operation, but using only a subset of the processes (e.</description></item><item><title>Lecture 4: Smoothers</title><link>https://teaching.wence.uk/comp4187/lectures/numerics/lecture4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/numerics/lecture4/</guid><description>In this lecture we will finish covering efficient matrix storage from: ipython notebook.
Alternatively, you can run the notebook online without installing python.
finite-differences After that we will start discussing efficient solvers for linear systems. This lecture will cover smoothers: ipython notebook.
Alternatively, you can run the notebook online without installing python.
smoothers-intro After the lecture have a look at the corresponding exercise.
The video is now available at: video</description></item><item><title>Lecture 5: Smoothers</title><link>https://teaching.wence.uk/comp4187/lectures/numerics/lecture5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/numerics/lecture5/</guid><description>This lecture will cover smoothers: ipython notebook.
Alternatively, you can run the notebook online without installing python.
smoothers-intro We also started on the multigrid method: ipython notebook
The video is now available at: video
The content of the whiteboard can be found below. It is also all contained in the ipython notebook itself.</description></item><item><title>Lecture 6: Multigrid</title><link>https://teaching.wence.uk/comp4187/lectures/numerics/lecture6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/numerics/lecture6/</guid><description>We continue with the multigrid method: ipython notebook
The video is now available at: video
The content of the whiteboard can be found below. It is also all contained in the ipython notebook itself.</description></item><item><title>Lecture 7: Multigrid</title><link>https://teaching.wence.uk/comp4187/lectures/numerics/lecture7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/numerics/lecture7/</guid><description>We continue with the multigrid method: ipython notebook
The proof for Poisson can be found in:
Dietrich Braess and Wolfgang Hackbusch,A New Convergence Proof for the Multi-grid Method including the V-Cycle, SIAM J. Numer. Anal.,20, 967–975, 1983 At this point you may want to have a look at the two exercises:
On two grid: exercise. If you are unused to Fourier-analysis you will find this exercise quite challenging.</description></item><item><title>Lecture 8: Time-stepping</title><link>https://teaching.wence.uk/comp4187/lectures/numerics/lecture8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/numerics/lecture8/</guid><description>We finish the discussion of multigrid method: ipython notebook
We will begin looking at time-stepping methods (for now in an ODE setting): ipython notebook
The video is now available at: video
The content of the whiteboard can be found below. It is also all contained in the ipython notebook itself.</description></item><item><title>Lecture 9: Time-stepping</title><link>https://teaching.wence.uk/comp4187/lectures/numerics/lecture9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/numerics/lecture9/</guid><description>We will finish time-stepping methods (for now in an ODE setting): ipython notebook and: ipython notebook.
Please go through the high-order part of the notebook on your own.
The video is now available at: video
The content of the whiteboard can be found below. It is also all contained in the ipython notebook itself.</description></item><item><title>Acknowledgements</title><link>https://teaching.wence.uk/comp4187/acknowledgements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/acknowledgements/</guid><description>Acknowledgements # Most of the course materials have been provided by Lawrence Mitchell.
Some of the material in the time integration notebooks is adapted from Jed Brown&amp;rsquo;s numerical computation class (https://github.com/cucs-numcomp/numcomp-class) under BSD 2-clause license.</description></item><item><title>Lecture 10: Space-time</title><link>https://teaching.wence.uk/comp4187/lectures/numerics/lecture10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/lectures/numerics/lecture10/</guid><description>We will try to combine what we have learned in time-stepping and in spatial discretisations.
ipython notebook.
The video is now available at: video
The content of the whiteboard can be found below. It is also all contained in the ipython notebook itself.</description></item><item><title/><link>https://teaching.wence.uk/comp4187/exercises/norms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/exercises/norms/</guid><description>If you find yourself confused by the norms used in the lecture work through this notebook on norms:
ipython notebook</description></item><item><title/><link>https://teaching.wence.uk/comp4187/setup/coursework/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/setup/coursework/</guid><description>The course is assessed by a single piece of coursework (due in Term 3: see the module handbook for dates). It will be available in Term 2.</description></item></channel></rss>